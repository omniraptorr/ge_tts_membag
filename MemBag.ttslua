local Coroutine = require("ge_tts/Coroutine")
local Logger = require("ge_tts/Logger")
local Instance = require("ge_tts/Instance")
local TableUtils = require('ge_tts/TableUtils')
local EventManager = require("ge_tts/EventManager")

---@class MemBagInstance : ge_tts__Instance

---@shape MemBag_entry
---@field pos tts__Vector
---@field rot tts__Vector
---@field lock nil | boolean
---@field parent nil | string
---@field currentParent nil | string

---@alias entries table<string, MemBag_entry>

---@shape MemBag_config
---@field smoothTake nil | boolean
---@field lift nil | number
---@field delay nil | number

---@type MemBag_config
local defaultConfig = {
	smoothTake = true,
	lift = 1,
	delay = 0.4,
}
local configMeta = {__index = defaultConfig}

---@shape MemBagInstance_SavedState : ge_tts__Instance_SavedState
---@field entries entries
---@field config MemBag_config

---@class static_MemBagInstance : ge_tts__static_Instance
---@overload fun(savedState: MemBagInstance_SavedState): CenteredMemBagInstance
---@overload fun(object: tts__Container): CenteredMemBagInstance
---@overload fun(object: tts__Container, objects: tts__Object[]): CenteredMemBagInstance
---@overload fun(object: tts__Container, objects: nil | tts__Object[], config: MemBag_config): CenteredMemBagInstance
local MemBagInstance = {}

MemBagInstance.INSTANCE_TYPE = "Absolute MemBag"

---Each object may only ever be a child of one MemBag. It also may not go into any bags except its designated parent.
---To enforce this we copy each MemBag entry into one big table to avoid collisions and to check against it when filtering.
---@type table<string, MemBagInstance>
local allEntries = {}


---collision checking happens here
---@param guid string
---@param instance MemBagInstance
local function addToAllEntries(guid, instance)
	Logger.assert(allEntries[guid] and allEntries[guid] ~= instance,
"instance " .. instance.getInstanceGuid() .. "tried to add duplicate entry for obj " .. guid ..
		"but it already belongs to instance " .. allEntries[guid].getInstanceGuid())

	allEntries[guid] = instance
end

local globalPlaceCallback_name = "__MemBagPlaceCallback"
local function MemBagPlaceCallback(obj)
	return allEntries[obj.getGUID()].entryPlaceCallback(obj)
end
Global.setVar(globalPlaceCallback_name, MemBagPlaceCallback)

---@param container tts__Object
---@param obj tts__Object
local function onObjectEnterContainer(container, obj)
	local guid = obj.getGUID()
	local realParent = allEntries[guid]
	if realParent then
		realParent.setParent(container)
	end
end

---@alias filterCallback fun(container: tts__Object, obj: tts__Object, result:any): boolean

--- this is the filtering part (always ask parent for permission before going anywhere)
---@param container tts__Object
---@param obj tts__Object
local function filterMemBagChild(container, obj)
	local parent = allEntries[obj.getGUID()]
	return parent and parent.filterObject(container, obj)
end

EventManager.addHandler("filterObjectEnterContainer", filterMemBagChild)

setmetatable(MemBagInstance, TableUtils.merge(getmetatable(Instance), {
	---@param objOrSavedState tts__Container | CenteredMemBagInstance_SavedState
	---@param nilOrEntries nil | entries
	---@param nilOrConfig nil | MemBag_config
	__call = function(objOrSavedState, nilOrEntries, nilOrConfig)
		local self = --[[---@type MemBagInstance]] Instance(objOrSavedState) -- super constructor

		---@type entries
		local entries
		---@type MemBag_config
		local config

		---@param entry MemBag_entry
		---@param guid string
		---@return MemBag_entry
		local function entryMapFunc(entry, guid)
			return self.addEntry(guid, entry)
		end

		local isSavedState = MemBagInstance.isSavedState(objOrSavedState)
		if isSavedState then
			local savedState = --[[---@type MemBagInstance_SavedState]] objOrSavedState

			config = setmetatable(savedState.config, configMeta)
			TableUtils.map(savedState.entries, entryMapFunc)
		else
			if nilOrEntries then
				TableUtils.map(--[[---@not nil]] nilOrEntries, entryMapFunc)
			else
				entries = {}
			end

			if nilOrConfig then
				config = setmetatable(TableUtils.copy(config), configMeta)
			else
				config = setmetatable({}, configMeta)
			end
		end

		local superSave = self.save
		-- Then, we replace this method with our own implementation...

		---@return MemBagInstance_SavedState
		function self.save()
			-- ge_tts__Instance (our super class) has its own data that it needs to save. So we call
			-- through to the original (super) save() method, and merge its result with our own data
			-- i.e. our object entries
			return --[[---@type MemBagInstance_SavedState]] TableUtils.merge(superSave(), {
				config = config,
				entries = entries,
			})
		end

		---@return string
		function self.getInstanceType()
			return MemBagInstance.INSTANCE_TYPE
		end

		local superGetObject = self.getObject
		---This overload is really just for Luanalysis, i didn't feel like casting to container every time
		---@return tts__Container
		function self.getObject()
			return superGetObject()
		end

		---Fetches existing entry instance
		---@param guid string
		---@return nil | MemBag_entry
		function self.getEntry(guid)
			return TableUtils.copy(entries[guid], true)
		end

		---@return entries
		function self.getAllEntries()
			return TableUtils.copy(entries, true)
		end

		---This is basically ripped from Instance.takeObject()
		---@param guid string
		---@return tts__IndexedSimpleObjectState | tts__Object
		function self.findEntry(guid)
			---@type tts__Container
			local parent

			local parentGUID = entries[guid].parent
			if parentGUID then
				parent = --[[---@type tts__Container]] getObjectFromGUID(--[[---@not nil]] parentGUID) -- jeez
				if parent == nil then
					error(string.format("MemBag %s: parent %s of entry %s doesn't exist", self.getInstanceGuid(), parentGUID, guid))
				end
				Logger.assert(parent.getObjects, "parent is not container wtf")
			end

			local nilOrState, _ = TableUtils.detect(parent.getObjects(), function(objectState)
				return objectState.guid == guid
			end)
			local nilOrObj = getObjectFromGUID(guid)

			Logger.assert(nilOrState or nilOrObj, "object with guid " .. guid .. "not found!")
			Logger.assert(not (nilOrState and nilOrObj), "objects with guid" .. guid .. " exist both in and out of parent!")

			return --[[---@not nil]] nilOrState or --[[---@not nil]] nilOrObj
		end

		---Straightforward but meant to be overridden
		---@param pos tts__CharVectorShape
		---@param rot tts__CharVectorShape
		---@return tts__Vector, tts__Vector
		function self.getTransform(pos, rot)
			return Vector(pos), Vector(rot)
		end

		---@param entry MemBag_entry
		---@return tts__Vector, tts__Vector
		function self.applyTransform(entry)
			return entry.pos, entry.rot
		end

		---Looks inside and outside self for matching object and makes an Instance for it, then adds it to entries.
		---Errors if matching object does not exist either directly in the scene or inside selfObj.
		---@param guid string
		---@param nilOrData nil | MemBag_entry
		---@return MemBag_entry
		---@overload fun(guid: string): ge_tts__Instance
		function self.addEntry(guid, nilOrData)
			addToAllEntries(guid, self)

			---@type tts__Object
			local entryObj

			---@type tts__Object | tts__IndexedSimpleObjectState
			local foundEntry = self.findEntry(guid)
			if type(foundEntry == "table") then
				entryObj = self.getObject()
			else -- it's an object
				entryObj = --[[---@type tts__Object]] foundEntry
			end

			if nilOrData then

				entries[guid] = --[[---@not nil]] TableUtils.copy(nilOrData)
			else
				local pos, rot = self.getTransform(entryObj.getPosition(), entryObj.getRotation())

				entries[guid] = {
					pos = pos,
					rot = rot,
					lock = entryObj.getLock()
				}
			end

			self.invalidateSavedState()
			return entries[guid]
		end

		---@param guid string
		function self.removeEntry(guid)
			entries[guid] = nil
			allEntries[guid] = nil
			self.invalidateSavedState()
		end

		function self.removeAllEntries()
			TableUtils.map(TableUtils.copy(entries), function(_, guid)
				return self.removeEntry(guid)
			end)
			self.invalidateSavedState()
		end


		---@param obj tts__Object
		function self.entryPlaceCallback(obj)
			local lock = entries[obj.getGUID()].lock or false
			obj.setLock(lock)
		end

		---@param guid string
		---@param nilOrSmoothTake nil | boolean
		function self.placeEntry(guid, nilOrSmoothTake)
			Logger.assert(entries[guid], "no entry with guid " .. guid)
			local entry = entries[guid]

			-- todo: man handling default args is awkward. ask for feedback on style
			local smoothTake = (nilOrSmoothTake == nil) and config.smoothTake or nilOrSmoothTake

			local foundEntry = self.findEntry(guid)

			local pos, rot = self.getTransform(guid)

			if type(foundEntry == "table") then
				---@type tts__Object_GuidTakeObjectParameters
				local params = {
					guid = guid,
					position = entry.pos,
					rotation = entry.rot,
					smooth = smoothTake,
					callback = globalPlaceCallback_name,
				}
				self.getObject().takeObject(params)
			else -- it's an object
				local entryObj = --[[---@type tts__Object]] foundEntry
				if smoothTake then

				else
					entryObj.setPosition(entry.pos)
					entryObj.setRotation(entry.rot)
				end
			end


			local entryObj = getObjectFromGUID(guid)

			-- todo: handle the issue where existing instance obj can get sucked into hands
			entryInstance.takeObject(--[[---@type ge_tts__Instance_TakeObjectOptions]] params)
			return entryInstance
		end

		---by default we only let children go into the parent bag
		---@param container tts__Object
		---@param obj tts__Object
		function self.filterObject(container, obj)
			--local entry = entries[obj.getGUID()] -- how to reference child's entry. we don't need it here tho

			if container == self.getObject() then
				return true
			end
		end

		---@param guid string
		---@param nilOrDelay nil | number
		function self.recallEntry(guid, nilOrDelay)

			---@type nil | number
			local delay
			if nilOrDelay == nil then
				delay = config.delay
			end

			local entryInstance = --[[---@not nil]] Instance.getInstance(guid)
			Logger.assert(entryInstance, "recallEntry(): Instance does not exist!")
			local entryObj = entryInstance.getObject()
			local selfObj = self.getObject()

			if entryObj == selfObj then -- it's already in!
				return
			end

			entryInstance.takeObject({
				smooth = true,
				position = entryObj.getPosition() + Vector(0,1,0),
				--todo: make callback local
				callback = function(obj)
					selfObj.putObject(obj)
				end,
			})
			if delay then
				Coroutine.yieldSeconds(--[[---@not nil]] delay)
			end
		end

		---@param guid string
		---@param nilOrHeight nil | boolean
		---@param nilOrDelay nil | number
		function self.liftEntry(guid, nilOrHeight, nilOrDelay)

		end




		---@param nilOrSmoothTake nil | boolean
		---@param nilOrDelay nil | number
		---@overload fun()
		function self.placeAll(nilOrSmoothTake, nilOrDelay)
			---@type nil | boolean
			local smoothTake
			if nilOrSmoothTake == nil then
				smoothTake = config.smoothTake
			else
				smoothTake = nilOrSmoothTake
			end

			---@type nil | number @ delay is passed on to individual funcs
			local delay
			if nilOrDelay == nil then
				delay = config.delay
			end

			--if delay then
			--	TableUtils.map(entries, function(_, guid)
			--		local out = self.placeEntry(guid, smoothTake)
			--		Coroutine.yieldSeconds(--[[---@not nil]] delay)
			--		return out
			--	end)
			--else
			--	TableUtils.map(entries, function(_, guid)
			--		return self.placeEntry(guid, smoothTake)
			--	end)
			--end
		end

		return self
	end,
	__index = Instance,
}))